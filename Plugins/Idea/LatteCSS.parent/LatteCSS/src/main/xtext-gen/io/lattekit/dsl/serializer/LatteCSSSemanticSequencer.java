/*
 * generated by Xtext 2.9.0.beta5
 */
package io.lattekit.dsl.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import io.lattekit.dsl.latteCSS.AlignmentProperty;
import io.lattekit.dsl.latteCSS.BackgroundFilterProperty;
import io.lattekit.dsl.latteCSS.BackgroundFilterTypeProperty;
import io.lattekit.dsl.latteCSS.BackgroundGravityProperty;
import io.lattekit.dsl.latteCSS.BackgroundRepeatProperty;
import io.lattekit.dsl.latteCSS.BorderProperty;
import io.lattekit.dsl.latteCSS.BorderRadiusProperty;
import io.lattekit.dsl.latteCSS.CSS;
import io.lattekit.dsl.latteCSS.ClassSelector;
import io.lattekit.dsl.latteCSS.ColorFunction;
import io.lattekit.dsl.latteCSS.ColorProperty;
import io.lattekit.dsl.latteCSS.ColorValue;
import io.lattekit.dsl.latteCSS.Definition;
import io.lattekit.dsl.latteCSS.DrawableProperty;
import io.lattekit.dsl.latteCSS.FontFamilyProperty;
import io.lattekit.dsl.latteCSS.FontStyleProperty;
import io.lattekit.dsl.latteCSS.HSBColor;
import io.lattekit.dsl.latteCSS.IdSelector;
import io.lattekit.dsl.latteCSS.LatteCSSPackage;
import io.lattekit.dsl.latteCSS.LinearGradient;
import io.lattekit.dsl.latteCSS.PaintProperty;
import io.lattekit.dsl.latteCSS.PseudoClassSelector;
import io.lattekit.dsl.latteCSS.RGBColor;
import io.lattekit.dsl.latteCSS.RadialGradient;
import io.lattekit.dsl.latteCSS.Selector;
import io.lattekit.dsl.latteCSS.ShorthandColorProperty;
import io.lattekit.dsl.latteCSS.ShorthandSizeProperty;
import io.lattekit.dsl.latteCSS.SimpleSelector;
import io.lattekit.dsl.latteCSS.SizeProperty;
import io.lattekit.dsl.latteCSS.SizeValue;
import io.lattekit.dsl.latteCSS.StopValue;
import io.lattekit.dsl.latteCSS.TimeValue;
import io.lattekit.dsl.latteCSS.TransitionProperty;
import io.lattekit.dsl.latteCSS.TransitionValue;
import io.lattekit.dsl.latteCSS.ViewSizeProperty;
import io.lattekit.dsl.latteCSS.ViewSizeValue;
import io.lattekit.dsl.services.LatteCSSGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LatteCSSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LatteCSSGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == LatteCSSPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case LatteCSSPackage.ALIGNMENT_PROPERTY:
				sequence_AlignmentProperty(context, (AlignmentProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BACKGROUND_FILTER_PROPERTY:
				sequence_BackgroundFilterProperty(context, (BackgroundFilterProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BACKGROUND_FILTER_TYPE_PROPERTY:
				sequence_BackgroundFilterTypeProperty(context, (BackgroundFilterTypeProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BACKGROUND_GRAVITY_PROPERTY:
				sequence_BackgroundGravityProperty(context, (BackgroundGravityProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BACKGROUND_REPEAT_PROPERTY:
				sequence_BackgroundRepeatProperty(context, (BackgroundRepeatProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BORDER_PROPERTY:
				sequence_BorderProperty(context, (BorderProperty) semanticObject); 
				return; 
			case LatteCSSPackage.BORDER_RADIUS_PROPERTY:
				sequence_BorderRadiusProperty(context, (BorderRadiusProperty) semanticObject); 
				return; 
			case LatteCSSPackage.CSS:
				sequence_CSS(context, (CSS) semanticObject); 
				return; 
			case LatteCSSPackage.CLASS_SELECTOR:
				sequence_ClassSelector(context, (ClassSelector) semanticObject); 
				return; 
			case LatteCSSPackage.COLOR_FUNCTION:
				sequence_ColorFunction(context, (ColorFunction) semanticObject); 
				return; 
			case LatteCSSPackage.COLOR_PROPERTY:
				sequence_ColorProperty(context, (ColorProperty) semanticObject); 
				return; 
			case LatteCSSPackage.COLOR_VALUE:
				sequence_ColorValue(context, (ColorValue) semanticObject); 
				return; 
			case LatteCSSPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case LatteCSSPackage.DRAWABLE_PROPERTY:
				sequence_DrawableProperty(context, (DrawableProperty) semanticObject); 
				return; 
			case LatteCSSPackage.FONT_FAMILY_PROPERTY:
				sequence_FontFamilyProperty(context, (FontFamilyProperty) semanticObject); 
				return; 
			case LatteCSSPackage.FONT_STYLE_PROPERTY:
				sequence_FontStyleProperty(context, (FontStyleProperty) semanticObject); 
				return; 
			case LatteCSSPackage.HSB_COLOR:
				sequence_HSBColor(context, (HSBColor) semanticObject); 
				return; 
			case LatteCSSPackage.ID_SELECTOR:
				sequence_IdSelector(context, (IdSelector) semanticObject); 
				return; 
			case LatteCSSPackage.LINEAR_GRADIENT:
				sequence_LinearGradient(context, (LinearGradient) semanticObject); 
				return; 
			case LatteCSSPackage.PAINT_PROPERTY:
				sequence_PaintProperty(context, (PaintProperty) semanticObject); 
				return; 
			case LatteCSSPackage.PSEUDO_CLASS_SELECTOR:
				sequence_PseudoClassSelector(context, (PseudoClassSelector) semanticObject); 
				return; 
			case LatteCSSPackage.RGB_COLOR:
				sequence_RGBColor(context, (RGBColor) semanticObject); 
				return; 
			case LatteCSSPackage.RADIAL_GRADIENT:
				sequence_RadialGradient(context, (RadialGradient) semanticObject); 
				return; 
			case LatteCSSPackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case LatteCSSPackage.SHORTHAND_COLOR_PROPERTY:
				sequence_ShorthandColorProperty(context, (ShorthandColorProperty) semanticObject); 
				return; 
			case LatteCSSPackage.SHORTHAND_SIZE_PROPERTY:
				sequence_ShorthandSizeProperty(context, (ShorthandSizeProperty) semanticObject); 
				return; 
			case LatteCSSPackage.SIMPLE_SELECTOR:
				sequence_SimpleSelector(context, (SimpleSelector) semanticObject); 
				return; 
			case LatteCSSPackage.SIZE_PROPERTY:
				sequence_SizeProperty(context, (SizeProperty) semanticObject); 
				return; 
			case LatteCSSPackage.SIZE_VALUE:
				sequence_SizeValue(context, (SizeValue) semanticObject); 
				return; 
			case LatteCSSPackage.STOP_VALUE:
				sequence_StopValue(context, (StopValue) semanticObject); 
				return; 
			case LatteCSSPackage.TIME_VALUE:
				sequence_TimeValue(context, (TimeValue) semanticObject); 
				return; 
			case LatteCSSPackage.TRANSITION_PROPERTY:
				sequence_TransitionProperty(context, (TransitionProperty) semanticObject); 
				return; 
			case LatteCSSPackage.TRANSITION_VALUE:
				sequence_TransitionValue(context, (TransitionValue) semanticObject); 
				return; 
			case LatteCSSPackage.VIEW_SIZE_PROPERTY:
				sequence_ViewSizeProperty(context, (ViewSizeProperty) semanticObject); 
				return; 
			case LatteCSSPackage.VIEW_SIZE_VALUE:
				sequence_ViewSizeValue(context, (ViewSizeValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (property='text-align' (value='left' | value='center' | value='right' | value='justify'))
	 */
	protected void sequence_AlignmentProperty(EObject context, AlignmentProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='background-filter' color=ColorValue filter=FilterValue?)
	 */
	protected void sequence_BackgroundFilterProperty(EObject context, BackgroundFilterProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='background-filter-type' value=FilterValue)
	 */
	protected void sequence_BackgroundFilterTypeProperty(EObject context, BackgroundFilterTypeProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY));
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.BACKGROUND_FILTER_TYPE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.BACKGROUND_FILTER_TYPE_PROPERTY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBackgroundFilterTypePropertyAccess().getPropertyBackgroundFilterTypeKeyword_0_0(), semanticObject.getProperty());
		feeder.accept(grammarAccess.getBackgroundFilterTypePropertyAccess().getValueFilterValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (property='background-gravity' values+=GravityValue values+=GravityValue*)
	 */
	protected void sequence_BackgroundGravityProperty(EObject context, BackgroundGravityProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='background-repeat' values+=RepeatValue values+=RepeatValue?)
	 */
	protected void sequence_BackgroundRepeatProperty(EObject context, BackgroundRepeatProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (property='border' | property='border-top' | property='border-bottom' | property='border-left' | property='border-right') 
	 *         width=SizeValue? 
	 *         (style='solid' | style='dashed' | style='dotted') 
	 *         color=ColorValue?
	 *     )
	 */
	protected void sequence_BorderProperty(EObject context, BorderProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (property='border-top-left-radius' | property='border-top-right-radius' | property='border-bottom-left-radius' | property='border-bottom-right-radius') 
	 *         values+=SizeValue+
	 *     )
	 */
	protected void sequence_BorderRadiusProperty(EObject context, BorderRadiusProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     definitions+=Definition+
	 */
	protected void sequence_CSS(EObject context, CSS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     class=ID
	 */
	protected void sequence_ClassSelector(EObject context, ClassSelector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.CLASS_SELECTOR__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.CLASS_SELECTOR__CLASS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClassSelectorAccess().getClassIDTerminalRuleCall_1_0(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((orig=ColorValue mod=NumberValue) | (orig=ColorValue (stopNumbers+=NumberValue stopColors+=ColorValue)+))
	 */
	protected void sequence_ColorFunction(EObject context, ColorFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             property='border-top-color' | 
	 *             property='border-left-color' | 
	 *             property='border-right-color' | 
	 *             property='border-bottom-color' | 
	 *             property='ripple-color' | 
	 *             property='background-color' | 
	 *             property='text-color' | 
	 *             property='background-filter-color'
	 *         ) 
	 *         value=ColorValue
	 *     )
	 */
	protected void sequence_ColorProperty(EObject context, ColorProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (namedColor=NamedColor | rgb=RGBColor)
	 */
	protected void sequence_ColorValue(EObject context, ColorValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (selector+=Selector selector+=Selector* properties+=CSSProperty+)
	 */
	protected void sequence_Definition(EObject context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='background-drawable' value=STRING)
	 */
	protected void sequence_DrawableProperty(EObject context, DrawableProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY));
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.DRAWABLE_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.DRAWABLE_PROPERTY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDrawablePropertyAccess().getPropertyBackgroundDrawableKeyword_0_0(), semanticObject.getProperty());
		feeder.accept(grammarAccess.getDrawablePropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (property='font-family' value=STRING)
	 */
	protected void sequence_FontFamilyProperty(EObject context, FontFamilyProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY));
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.FONT_FAMILY_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.FONT_FAMILY_PROPERTY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFontFamilyPropertyAccess().getPropertyFontFamilyKeyword_0_0(), semanticObject.getProperty());
		feeder.accept(grammarAccess.getFontFamilyPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (property='font-style' (value='normal' | value='bold' | value='bold-italic'))
	 */
	protected void sequence_FontStyleProperty(EObject context, FontStyleProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (hue=NumberValue saturation=NumberValue brightness=NumberValue) | 
	 *         (hue=NumberValue saturation=NumberValue brightness=NumberValue alpha=NumberValue)
	 *     )
	 */
	protected void sequence_HSBColor(EObject context, HSBColor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_IdSelector(EObject context, IdSelector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.ID_SELECTOR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.ID_SELECTOR__ID));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIdSelectorAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (x1=SizeValue y1=SizeValue x2=SizeValue y2=SizeValue stops+=StopValue+)
	 */
	protected void sequence_LinearGradient(EObject context, LinearGradient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='background' value=PaintValue)
	 */
	protected void sequence_PaintProperty(EObject context, PaintProperty semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.CSS_PROPERTY__PROPERTY));
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.PAINT_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.PAINT_PROPERTY__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPaintPropertyAccess().getPropertyBackgroundKeyword_0_0(), semanticObject.getProperty());
		feeder.accept(grammarAccess.getPaintPropertyAccess().getValuePaintValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_PseudoClassSelector(EObject context, PseudoClassSelector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.PSEUDO_CLASS_SELECTOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.PSEUDO_CLASS_SELECTOR__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPseudoClassSelectorAccess().getValueIDTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (hex=HEX_NUMBER | (r=IntegerValue g=IntegerValue b=IntegerValue) | (r=IntegerValue g=IntegerValue b=IntegerValue alpha=NumberValue))
	 */
	protected void sequence_RGBColor(EObject context, RGBColor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((cx=SizeValue cy=SizeValue)? radius=SizeValue fx=SizeValue fy=SizeValue stops+=StopValue+)
	 */
	protected void sequence_RadialGradient(EObject context, RadialGradient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     simpleSelector+=SimpleSelector+
	 */
	protected void sequence_Selector(EObject context, Selector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='border-color' values+=ColorValue+)
	 */
	protected void sequence_ShorthandColorProperty(EObject context, ShorthandColorProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((property='border-width' | property='border-radius' | property='margin' | property='padding') values+=SizeValue+)
	 */
	protected void sequence_ShorthandSizeProperty(EObject context, ShorthandSizeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (element=ID | (id=IdSelector pseudoClass=PseudoClassSelector?) | (class=ClassSelector pseudoClass=PseudoClassSelector?))
	 */
	protected void sequence_SimpleSelector(EObject context, SimpleSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             property='border-left-width' | 
	 *             property='border-right-width' | 
	 *             property='border-top-width' | 
	 *             property='border-bottom-width' | 
	 *             property='font-size' | 
	 *             property='translate-x' | 
	 *             property='translate-y' | 
	 *             property='margin-left' | 
	 *             property='margin-right' | 
	 *             property='margin-top' | 
	 *             property='margin-bottom' | 
	 *             property='padding-left' | 
	 *             property='padding-right' | 
	 *             property='padding-top' | 
	 *             property='padding-bottom' | 
	 *             property='x' | 
	 *             property='y' | 
	 *             property='elevation'
	 *         ) 
	 *         value=SizeValue
	 *     )
	 */
	protected void sequence_SizeProperty(EObject context, SizeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=NumberValue (dimension='dp' | dimension='px' | dimension='sp' | dimension='pt' | dimension='mm')?)
	 */
	protected void sequence_SizeValue(EObject context, SizeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pos=SizeValue color=ColorValue)
	 */
	protected void sequence_StopValue(EObject context, StopValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.STOP_VALUE__POS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.STOP_VALUE__POS));
			if(transientValues.isValueTransient(semanticObject, LatteCSSPackage.Literals.STOP_VALUE__COLOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LatteCSSPackage.Literals.STOP_VALUE__COLOR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStopValueAccess().getPosSizeValueParserRuleCall_0_0(), semanticObject.getPos());
		feeder.accept(grammarAccess.getStopValueAccess().getColorColorValueParserRuleCall_2_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (time=NumberValue (unit='s' | unit='ms'))
	 */
	protected void sequence_TimeValue(EObject context, TimeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property='transition' transitions+=TransitionValue transitions+=TransitionValue*)
	 */
	protected void sequence_TransitionProperty(EObject context, TransitionProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (propertyName=PropertyNameValue duration=TimeValue timingFunction=TimingFunction? delay=TimeValue?)
	 */
	protected void sequence_TransitionValue(EObject context, TransitionValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((property='width' | property='height') value=ViewSizeValue)
	 */
	protected void sequence_ViewSizeProperty(EObject context, ViewSizeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=SizeValue | dynamic='match_parent' | dynamic='wrap_content')
	 */
	protected void sequence_ViewSizeValue(EObject context, ViewSizeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
